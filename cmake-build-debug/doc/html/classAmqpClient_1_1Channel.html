<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SimpleAmqpClient: AmqpClient::Channel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SimpleAmqpClient
   &#160;<span id="projectnumber">2.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>AmqpClient</b></li><li class="navelem"><a class="el" href="classAmqpClient_1_1Channel.html">Channel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classAmqpClient_1_1Channel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AmqpClient::Channel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Channel_8h_source.html">Channel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AmqpClient::Channel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAmqpClient_1_1Channel.png" usemap="#AmqpClient::Channel_map" alt=""/>
  <map id="AmqpClient::Channel_map" name="AmqpClient::Channel_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab7b32ab80f776b1c20dfb08667b85eba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7b32ab80f776b1c20dfb08667b85eba"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ptr_t</b></td></tr>
<tr class="separator:ab7b32ab80f776b1c20dfb08667b85eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0320ded142be96a5d8a419af48a1070b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0320ded142be96a5d8a419af48a1070b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Channel</b> (const std::string &amp;host, int port, const std::string &amp;username, const std::string &amp;password, const std::string &amp;vhost, int frame_max)</td></tr>
<tr class="separator:a0320ded142be96a5d8a419af48a1070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ef4677d26f9d3290b9c79b15df8990"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7ef4677d26f9d3290b9c79b15df8990"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Channel</b> (const std::string &amp;host, int port, const std::string &amp;username, const std::string &amp;password, const std::string &amp;vhost, int frame_max, const SSLConnectionParams &amp;ssl_params)</td></tr>
<tr class="separator:ad7ef4677d26f9d3290b9c79b15df8990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b44093f03f2ff80a899c24bfa6f3cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#ab1b44093f03f2ff80a899c24bfa6f3cd">DeclareExchange</a> (const std::string &amp;exchange_name, const std::string &amp;exchange_type=Channel::EXCHANGE_TYPE_DIRECT, bool passive=false, bool durable=false, bool auto_delete=false)</td></tr>
<tr class="separator:ab1b44093f03f2ff80a899c24bfa6f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3693e5617321ee6f6a089ae18b52659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#aa3693e5617321ee6f6a089ae18b52659">DeclareExchange</a> (const std::string &amp;exchange_name, const std::string &amp;exchange_type, bool passive, bool durable, bool auto_delete, const Table &amp;arguments)</td></tr>
<tr class="separator:aa3693e5617321ee6f6a089ae18b52659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac2b0a1fcdbe691bb1b72c460dafb0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#afac2b0a1fcdbe691bb1b72c460dafb0b">DeleteExchange</a> (const std::string &amp;exchange_name, bool if_unused=false)</td></tr>
<tr class="separator:afac2b0a1fcdbe691bb1b72c460dafb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae614e4e067b9e834b0367aec25b6fb44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#ae614e4e067b9e834b0367aec25b6fb44">BindExchange</a> (const std::string &amp;destination, const std::string &amp;source, const std::string &amp;routing_key)</td></tr>
<tr class="separator:ae614e4e067b9e834b0367aec25b6fb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27028c625f83bb5ff1bd7956a74c88dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a27028c625f83bb5ff1bd7956a74c88dc">BindExchange</a> (const std::string &amp;destination, const std::string &amp;source, const std::string &amp;routing_key, const Table &amp;arguments)</td></tr>
<tr class="separator:a27028c625f83bb5ff1bd7956a74c88dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb27cca5c1f9a8a674497a6af8c08765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#acb27cca5c1f9a8a674497a6af8c08765">UnbindExchange</a> (const std::string &amp;destination, const std::string &amp;source, const std::string &amp;routing_key)</td></tr>
<tr class="separator:acb27cca5c1f9a8a674497a6af8c08765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8ad496467f5823097e8293f397ad68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#aaa8ad496467f5823097e8293f397ad68">UnbindExchange</a> (const std::string &amp;destination, const std::string &amp;source, const std::string &amp;routing_key, const Table &amp;arguments)</td></tr>
<tr class="separator:aaa8ad496467f5823097e8293f397ad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12550aaf41bf053be2821556e24fff32"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a12550aaf41bf053be2821556e24fff32">DeclareQueue</a> (const std::string &amp;queue_name, bool passive=false, bool durable=false, bool exclusive=true, bool auto_delete=true)</td></tr>
<tr class="separator:a12550aaf41bf053be2821556e24fff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c10125d0594225045f1b2b9c77d34f5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a1c10125d0594225045f1b2b9c77d34f5">DeclareQueue</a> (const std::string &amp;queue_name, bool passive, bool durable, bool exclusive, bool auto_delete, const Table &amp;arguments)</td></tr>
<tr class="separator:a1c10125d0594225045f1b2b9c77d34f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1a6cf9bde40ba9fc9d00c38e4b0af7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a9f1a6cf9bde40ba9fc9d00c38e4b0af7">DeclareQueueWithCounts</a> (const std::string &amp;queue_name, boost::uint32_t &amp;message_count, boost::uint32_t &amp;consumer_count, bool passive=false, bool durable=false, bool exclusive=true, bool auto_delete=true)</td></tr>
<tr class="separator:a9f1a6cf9bde40ba9fc9d00c38e4b0af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24acc5f08b99944a8277e5643c38d7c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a24acc5f08b99944a8277e5643c38d7c0">DeclareQueueWithCounts</a> (const std::string &amp;queue_name, boost::uint32_t &amp;message_count, boost::uint32_t &amp;consumer_count, bool passive, bool durable, bool exclusive, bool auto_delete, const Table &amp;arguments)</td></tr>
<tr class="separator:a24acc5f08b99944a8277e5643c38d7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7393af62804d1b9eb03626465ac44696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a7393af62804d1b9eb03626465ac44696">DeleteQueue</a> (const std::string &amp;queue_name, bool if_unused=false, bool if_empty=false)</td></tr>
<tr class="separator:a7393af62804d1b9eb03626465ac44696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24ef000a161f1a4f7e307a0d9d5edac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#ae24ef000a161f1a4f7e307a0d9d5edac">BindQueue</a> (const std::string &amp;queue_name, const std::string &amp;exchange_name, const std::string &amp;routing_key=&quot;&quot;)</td></tr>
<tr class="separator:ae24ef000a161f1a4f7e307a0d9d5edac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd925b2cdbea1dc62610a3a481692be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a0cd925b2cdbea1dc62610a3a481692be">BindQueue</a> (const std::string &amp;queue_name, const std::string &amp;exchange_name, const std::string &amp;routing_key, const Table &amp;arguments)</td></tr>
<tr class="separator:a0cd925b2cdbea1dc62610a3a481692be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadec3cab20eab13ca2b9d326da88e2f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#aadec3cab20eab13ca2b9d326da88e2f1">UnbindQueue</a> (const std::string &amp;queue_name, const std::string &amp;exchange_name, const std::string &amp;routing_key=&quot;&quot;)</td></tr>
<tr class="separator:aadec3cab20eab13ca2b9d326da88e2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71573f5c8b13c83891c8e591e340782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#ae71573f5c8b13c83891c8e591e340782">UnbindQueue</a> (const std::string &amp;queue_name, const std::string &amp;exchange_name, const std::string &amp;routing_key, const Table &amp;arguments)</td></tr>
<tr class="separator:ae71573f5c8b13c83891c8e591e340782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f782380ea9a2424a6328017182b7d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a68f782380ea9a2424a6328017182b7d4">PurgeQueue</a> (const std::string &amp;queue_name)</td></tr>
<tr class="separator:a68f782380ea9a2424a6328017182b7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197356e12edbf9a3418aa9a89a3f6b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a197356e12edbf9a3418aa9a89a3f6b8a">BasicAck</a> (const Envelope::ptr_t &amp;message)</td></tr>
<tr class="separator:a197356e12edbf9a3418aa9a89a3f6b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3a534b6a55baf0c9e9ff04ee0a2c6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a4a3a534b6a55baf0c9e9ff04ee0a2c6a">BasicAck</a> (const <a class="el" href="structAmqpClient_1_1Envelope_1_1DeliveryInfo.html">Envelope::DeliveryInfo</a> &amp;info)</td></tr>
<tr class="separator:a4a3a534b6a55baf0c9e9ff04ee0a2c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa576fe056e9a1fc35af28b1e45a40e34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#aa576fe056e9a1fc35af28b1e45a40e34">BasicReject</a> (const Envelope::ptr_t &amp;message, bool requeue, bool multiple=false)</td></tr>
<tr class="separator:aa576fe056e9a1fc35af28b1e45a40e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeec8ea95b9a47ce2ad11a58ad4aaf5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#aaeec8ea95b9a47ce2ad11a58ad4aaf5f">BasicReject</a> (const <a class="el" href="structAmqpClient_1_1Envelope_1_1DeliveryInfo.html">Envelope::DeliveryInfo</a> &amp;info, bool requeue, bool multiple=false)</td></tr>
<tr class="separator:aaeec8ea95b9a47ce2ad11a58ad4aaf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409ac5dea0471d850ff6191f58d5fe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a1409ac5dea0471d850ff6191f58d5fe7">BasicPublish</a> (const std::string &amp;exchange_name, const std::string &amp;routing_key, const BasicMessage::ptr_t message, bool mandatory=false, bool immediate=false)</td></tr>
<tr class="separator:a1409ac5dea0471d850ff6191f58d5fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde66314f32745bde6aea04df7144423"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#abde66314f32745bde6aea04df7144423">BasicGet</a> (Envelope::ptr_t &amp;message, const std::string &amp;queue, bool no_ack=true)</td></tr>
<tr class="separator:abde66314f32745bde6aea04df7144423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5375f0cc515162c8724ffcb7d741b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#aa5375f0cc515162c8724ffcb7d741b0f">BasicRecover</a> (const std::string &amp;consumer)</td></tr>
<tr class="separator:aa5375f0cc515162c8724ffcb7d741b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5c6debdb77869a5aaf51c7605b48c9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a6e5c6debdb77869a5aaf51c7605b48c9">BasicConsume</a> (const std::string &amp;queue, const std::string &amp;consumer_tag=&quot;&quot;, bool no_local=true, bool no_ack=true, bool exclusive=true, boost::uint16_t message_prefetch_count=1)</td></tr>
<tr class="separator:a6e5c6debdb77869a5aaf51c7605b48c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b6241faaeb4bf1e33ca71b0e725f81"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#ab1b6241faaeb4bf1e33ca71b0e725f81">BasicConsume</a> (const std::string &amp;queue, const std::string &amp;consumer_tag, bool no_local, bool no_ack, bool exclusive, boost::uint16_t message_prefetch_count, const Table &amp;arguments)</td></tr>
<tr class="separator:ab1b6241faaeb4bf1e33ca71b0e725f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb5e4d5fd17bc911389e6fe44dd60d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#abeb5e4d5fd17bc911389e6fe44dd60d5">BasicQos</a> (const std::string &amp;consumer_tag, boost::uint16_t message_prefetch_count)</td></tr>
<tr class="separator:abeb5e4d5fd17bc911389e6fe44dd60d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bd0554526cf18f35267bf26a959067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#af2bd0554526cf18f35267bf26a959067">BasicCancel</a> (const std::string &amp;consumer_tag)</td></tr>
<tr class="separator:af2bd0554526cf18f35267bf26a959067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd54d2411dff687de259f506c41ad62"><td class="memItemLeft" align="right" valign="top">Envelope::ptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a4bd54d2411dff687de259f506c41ad62">BasicConsumeMessage</a> (const std::string &amp;consumer_tag)</td></tr>
<tr class="separator:a4bd54d2411dff687de259f506c41ad62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7129c776c19d0ee4c2eb55d8c3e6b433"><td class="memItemLeft" align="right" valign="top">Envelope::ptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a7129c776c19d0ee4c2eb55d8c3e6b433">BasicConsumeMessage</a> (const std::vector&lt; std::string &gt; &amp;consumer_tags)</td></tr>
<tr class="separator:a7129c776c19d0ee4c2eb55d8c3e6b433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457e076731e8e193f07e6ffc5ec17a0f"><td class="memItemLeft" align="right" valign="top">Envelope::ptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a457e076731e8e193f07e6ffc5ec17a0f">BasicConsumeMessage</a> ()</td></tr>
<tr class="separator:a457e076731e8e193f07e6ffc5ec17a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8994f25726f6bd4abcd122d060a71d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#ad8994f25726f6bd4abcd122d060a71d7">BasicConsumeMessage</a> (const std::string &amp;consumer_tag, Envelope::ptr_t &amp;envelope, int timeout=-1)</td></tr>
<tr class="separator:ad8994f25726f6bd4abcd122d060a71d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f9d2b14fd356a1a2febc01959cea0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#aa8f9d2b14fd356a1a2febc01959cea0c">BasicConsumeMessage</a> (const std::vector&lt; std::string &gt; &amp;consumer_tags, Envelope::ptr_t &amp;envelope, int timeout=-1)</td></tr>
<tr class="separator:aa8f9d2b14fd356a1a2febc01959cea0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5edb9a2b174cf7bfe13d2b87c7f06c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#ab5edb9a2b174cf7bfe13d2b87c7f06c9">BasicConsumeMessage</a> (Envelope::ptr_t &amp;envelope, int timeout=-1)</td></tr>
<tr class="separator:ab5edb9a2b174cf7bfe13d2b87c7f06c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a40a9cd7087913e23e91f305a4a601ec3"><td class="memItemLeft" align="right" valign="top">static ptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a40a9cd7087913e23e91f305a4a601ec3">Create</a> (const std::string &amp;host=&quot;127.0.0.1&quot;, int port=5672, const std::string &amp;username=&quot;guest&quot;, const std::string &amp;password=&quot;guest&quot;, const std::string &amp;vhost=&quot;/&quot;, int frame_max=131072)</td></tr>
<tr class="separator:a40a9cd7087913e23e91f305a4a601ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0506a8d47f576c8f4c62de6fb93468f1"><td class="memItemLeft" align="right" valign="top">static ptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a0506a8d47f576c8f4c62de6fb93468f1">CreateSecure</a> (const std::string &amp;path_to_ca_cert=&quot;&quot;, const std::string &amp;host=&quot;127.0.0.1&quot;, const std::string &amp;path_to_client_key=&quot;&quot;, const std::string &amp;path_to_client_cert=&quot;&quot;, int port=5671, const std::string &amp;username=&quot;guest&quot;, const std::string &amp;password=&quot;guest&quot;, const std::string &amp;vhost=&quot;/&quot;, int frame_max=131072, bool verify_hostname=true)</td></tr>
<tr class="separator:a0506a8d47f576c8f4c62de6fb93468f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34d478301d58af94af18d2859e5d156"><td class="memItemLeft" align="right" valign="top">static ptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#ac34d478301d58af94af18d2859e5d156">CreateFromUri</a> (const std::string &amp;uri, int frame_max=131072)</td></tr>
<tr class="separator:ac34d478301d58af94af18d2859e5d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be1630633019b433df2bde099ed010d"><td class="memItemLeft" align="right" valign="top">static ptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmqpClient_1_1Channel.html#a0be1630633019b433df2bde099ed010d">CreateSecureFromUri</a> (const std::string &amp;uri, const std::string &amp;path_to_ca_cert, const std::string &amp;path_to_client_key=&quot;&quot;, const std::string &amp;path_to_client_cert=&quot;&quot;, bool verify_hostname=true, int frame_max=131072)</td></tr>
<tr class="separator:a0be1630633019b433df2bde099ed010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a19a0f13be32765c5e4033cd5896e5975"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19a0f13be32765c5e4033cd5896e5975"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>EXCHANGE_TYPE_DIRECT</b></td></tr>
<tr class="separator:a19a0f13be32765c5e4033cd5896e5975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93d7c55650372e5de837d3d1fab68fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac93d7c55650372e5de837d3d1fab68fc"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>EXCHANGE_TYPE_FANOUT</b></td></tr>
<tr class="separator:ac93d7c55650372e5de837d3d1fab68fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af41dee5ee331baee8d2afd3364d74e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2af41dee5ee331baee8d2afd3364d74e"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>EXCHANGE_TYPE_TOPIC</b></td></tr>
<tr class="separator:a2af41dee5ee331baee8d2afd3364d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a203cb4a9976b3236b500c0187897329c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a203cb4a9976b3236b500c0187897329c"></a>
boost::scoped_ptr&lt; <a class="el" href="classAmqpClient_1_1Detail_1_1ChannelImpl.html">Detail::ChannelImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_impl</b></td></tr>
<tr class="separator:a203cb4a9976b3236b500c0187897329c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bcd4578322a5689a971d75f4010832"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53bcd4578322a5689a971d75f4010832"></a>
AmqpClient::Connection::ptr_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_connection</b></td></tr>
<tr class="separator:a53bcd4578322a5689a971d75f4010832"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A single channel Represents a logical AMQP channel over a connection </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a197356e12edbf9a3418aa9a89a3f6b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BasicAck </td>
          <td>(</td>
          <td class="paramtype">const Envelope::ptr_t &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acknowledges a Basic message Acknowledges a message delievered using BasicGet or BasicConsume </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message that is being ack'ed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a3a534b6a55baf0c9e9ff04ee0a2c6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BasicAck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAmqpClient_1_1Envelope_1_1DeliveryInfo.html">Envelope::DeliveryInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acknowledges a Basic message Acknowledges a message delivered using BasicGet or BasicConsume, this overload doesn't require the <a class="el" href="classAmqpClient_1_1Envelope.html">Envelope</a> object to Acknowledge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delivery_info</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2bd0554526cf18f35267bf26a959067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BasicCancel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>consumer_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels a previously created Consumer Unsubscribes as a consumer to a queue. In otherwords undoes what BasicConsume does. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer_tag</td><td>The same consumer_tag used when the consumer was created with BasicConsume </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classAmqpClient_1_1Channel.html#a6e5c6debdb77869a5aaf51c7605b48c9">BasicConsume</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6e5c6debdb77869a5aaf51c7605b48c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AmqpClient::Channel::BasicConsume </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>consumer_tag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_local</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_ack</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::uint16_t&#160;</td>
          <td class="paramname"><em>message_prefetch_count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts consuming Basic messages on a queue Subscribes as a consumer to a queue, so all future messages on a queue will be Basic.Delivered Note: due to a limitation to how things are done, it is only possible to reliably have a single consumer per channel, calling this more than once per channel may result in undefined results from BasicConsumeMessage </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the name of the queue to subscribe to </td></tr>
    <tr><td class="paramname">consumer_tag</td><td>the name of the consumer. This is used to do operations with a consumer </td></tr>
    <tr><td class="paramname">no_local</td><td>Defaults to true </td></tr>
    <tr><td class="paramname">no_ack</td><td>If true, ack'ing the message is automatically done when the message is delivered. Defaults to true (message does not have to be ack'ed) </td></tr>
    <tr><td class="paramname">exclusive</td><td>means only this consumer can access the queue. Defaults to true </td></tr>
    <tr><td class="paramname">message_prefetch_count</td><td>number of unacked messages the broker will deliver. Setting this to more than 1 will allow the broker to deliver messages while a current message is being processed for example. A value of 0 means no limit. This option is ignored if no_ack = true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the consumer tag </dd></dl>

</div>
</div>
<a class="anchor" id="ab1b6241faaeb4bf1e33ca71b0e725f81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AmqpClient::Channel::BasicConsume </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>consumer_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::uint16_t&#160;</td>
          <td class="paramname"><em>message_prefetch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts consuming Basic messages on a queue Subscribes as a consumer to a queue, so all future messages on a queue will be Basic.Delivered Note: due to a limitation to how things are done, it is only possible to reliably have a single consumer per channel, calling this more than once per channel may result in undefined results from BasicConsumeMessage </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the name of the queue to subscribe to </td></tr>
    <tr><td class="paramname">consumer_tag</td><td>the name of the consumer. This is used to do operations with a consumer </td></tr>
    <tr><td class="paramname">no_local</td><td>Defaults to true </td></tr>
    <tr><td class="paramname">no_ack</td><td>If true, ack'ing the message is automatically done when the message is delivered. Defaults to true (message does not have to be ack'ed) </td></tr>
    <tr><td class="paramname">exclusive</td><td>means only this consumer can access the queue. Defaults to true </td></tr>
    <tr><td class="paramname">message_prefetch_count</td><td>number of unacked messages the broker will deliver. Setting this to more than 1 will allow the broker to deliver messages while a current message is being processed for example. A value of 0 means no limit. This option is ignored if no_ack = true </td></tr>
    <tr><td class="paramname">arguments</td><td>A table of additional arguments when creating the consumer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the consumer tag </dd></dl>

</div>
</div>
<a class="anchor" id="a4bd54d2411dff687de259f506c41ad62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Envelope::ptr_t AmqpClient::Channel::BasicConsumeMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>consumer_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes a single message Waits for a single Basic message to be Delivered. This function only works after BasicConsume has successfully been called. </p><dl class="section return"><dt>Returns</dt><dd>The next message on the queue </dd></dl>

</div>
</div>
<a class="anchor" id="a7129c776c19d0ee4c2eb55d8c3e6b433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Envelope::ptr_t AmqpClient::Channel::BasicConsumeMessage </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>consumer_tags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes a single message from a list of consumers Waits for a single message to be delivered from a list of consumers. This function only works after BasicConsume has been called.</p>
<dl class="section return"><dt>Returns</dt><dd>the next message delivered from the broker </dd></dl>

</div>
</div>
<a class="anchor" id="a457e076731e8e193f07e6ffc5ec17a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Envelope::ptr_t AmqpClient::Channel::BasicConsumeMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes a single message from any open consumers Waits for a message from any consumer open on this <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> object. This function only works after BasicConsume has been called.</p>
<dl class="section return"><dt>Returns</dt><dd>the next message delivered from the broker </dd></dl>

</div>
</div>
<a class="anchor" id="ad8994f25726f6bd4abcd122d060a71d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AmqpClient::Channel::BasicConsumeMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>consumer_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Envelope::ptr_t &amp;&#160;</td>
          <td class="paramname"><em>envelope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes a single message with a timeout (this gets an envelope object) Waits for a single Basic message to be Delivered or the timeout to expire. This function only works after BasicConsume as been successfully called. This function differs in that it returns an envelope object which contains more information about the message delivered </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envelope</td><td>the message object to save it to. Is ok to be an empty pointer </td></tr>
    <tr><td class="paramname">timeout</td><td>the timeout for the first part of the message to be delivered in ms </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classAmqpClient_1_1MessageReturnedException.html">MessageReturnedException</a></td><td>if a basic.return is received while waiting for a message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was delivered before the timeout, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aa8f9d2b14fd356a1a2febc01959cea0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AmqpClient::Channel::BasicConsumeMessage </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>consumer_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Envelope::ptr_t &amp;&#160;</td>
          <td class="paramname"><em>envelope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes a single message with a timeout from a list of consumers</p>
<p>Waits for a single message to be delivered to one of the listed consumer tags to be delivered or for the timeout to expire. This function only works after BasicConsume has been successfully called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer_tags</td><td>[in] a list of the consumer tags to wait for a message from </td></tr>
    <tr><td class="paramname">envelope</td><td>[out] the message object that is delivered. </td></tr>
    <tr><td class="paramname">timeout</td><td>[in] the timeout in milliseconds for the message to be delivered. 0 works like a non-blocking read, -1 is an infinite timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was delivered before the timeout, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5edb9a2b174cf7bfe13d2b87c7f06c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AmqpClient::Channel::BasicConsumeMessage </td>
          <td>(</td>
          <td class="paramtype">Envelope::ptr_t &amp;&#160;</td>
          <td class="paramname"><em>envelope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consumes a single message from any consumers opened for this <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> object</p>
<p>Waits for a single message to be delivered to one of the consumers opened on this <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> object to be delivered, or for the timeout to occur. This function only works after BasicConsume has been successfully called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envelope</td><td>[out] the message object that is delivered. </td></tr>
    <tr><td class="paramname">timeout</td><td>[in] the timeout in milliseconds for the message to be delivered. 0 works like a non-blocking read, -1 is an infinite timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message delivered before the timeout, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="abde66314f32745bde6aea04df7144423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AmqpClient::Channel::BasicGet </td>
          <td>(</td>
          <td class="paramtype">Envelope::ptr_t &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_ack</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to get a message from a queue in a synchronous manner</p>
<p>Note that this function effectively polls the broker for a message, in general better performance is realized using BasicConsume/BasicConsumeMessage. This function will not wait for a message to arrive in a queue, it will return false if the queue is empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>a message envelope pointer that will be populated if a message is delivered </td></tr>
    <tr><td class="paramname">queue</td><td>the name of the queue to try to get the message from </td></tr>
    <tr><td class="paramname">no_ack</td><td>if the message does not need to be ack'ed. Default true (message does not need to be acked) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was delivered, false if the queue was empty </dd></dl>

</div>
</div>
<a class="anchor" id="a1409ac5dea0471d850ff6191f58d5fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BasicPublish </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>routing_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasicMessage::ptr_t&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mandatory</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>immediate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Publishes a Basic message Publishes a Basic message to an exchange </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exchange_name</td><td>The name of the exchange to publish the message to </td></tr>
    <tr><td class="paramname">routing_key</td><td>The routing key to publish with, this is used to route to the correct queue </td></tr>
    <tr><td class="paramname">message</td><td>the <a class="el" href="classAmqpClient_1_1BasicMessage.html">BasicMessage</a> object to publish to the queue </td></tr>
    <tr><td class="paramname">mandatory</td><td>requires the message to be delivered to a queue. A <a class="el" href="classAmqpClient_1_1MessageReturnedException.html">MessageReturnedException</a> is thrown if the message cannot be routed to a queue. Defaults to false </td></tr>
    <tr><td class="paramname">immediate</td><td>requires the message to be both routed to a queue, and immediately delivered via a consumer if the message is not routed, or a consumer cannot immediately deliver the message a <a class="el" href="classAmqpClient_1_1MessageReturnedException.html">MessageReturnedException</a> is thrown. Defaults to false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abeb5e4d5fd17bc911389e6fe44dd60d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BasicQos </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>consumer_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::uint16_t&#160;</td>
          <td class="paramname"><em>message_prefetch_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the number of unacknowledged messages that will be delivered by the broker to a consumer. Note this effectively has no effect for consumer with no_ack set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer_tag</td><td>the conumser tag to adjust the prefect </td></tr>
    <tr><td class="paramname">message_prefetch_count</td><td>the number of unacknowledged message the broker will deliver. A value of 0 means no limit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5375f0cc515162c8724ffcb7d741b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BasicRecover </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>consumer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Redeliver any unacknowledged messages delivered from the broker </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer</td><td>the consumer to recover message from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa576fe056e9a1fc35af28b1e45a40e34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BasicReject </td>
          <td>(</td>
          <td class="paramtype">const Envelope::ptr_t &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requeue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multiple</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reject a Basic message Rejects a message delievered using BasicGet or BasicConsume </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message that is being nack'ed </td></tr>
    <tr><td class="paramname">requeue</td><td>tells the broker to requeue the message or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaeec8ea95b9a47ce2ad11a58ad4aaf5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BasicReject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAmqpClient_1_1Envelope_1_1DeliveryInfo.html">Envelope::DeliveryInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requeue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multiple</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reject a Basic message Rejects a message delivered using BasicGet or BasicConsume, this overload doesn't require the <a class="el" href="classAmqpClient_1_1Envelope.html">Envelope</a> object to Reject </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delivery_info</td><td></td></tr>
    <tr><td class="paramname">requeue</td><td>tells the broker to requeue the message or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae614e4e067b9e834b0367aec25b6fb44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BindExchange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>routing_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds one exchange to another exchange using a given key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>the name of the exchange to route messages to </td></tr>
    <tr><td class="paramname">source</td><td>the name of the exchange to route messages from </td></tr>
    <tr><td class="paramname">routing_key</td><td>the routing key to use when binding </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27028c625f83bb5ff1bd7956a74c88dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BindExchange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>routing_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds one exchange to another exchange using a given key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>the name of the exchange to route messages to </td></tr>
    <tr><td class="paramname">source</td><td>the name of the exchange to route messages from </td></tr>
    <tr><td class="paramname">routing_key</td><td>the routing key to use when binding </td></tr>
    <tr><td class="paramname">arguments</td><td>A table of additional arguments used when creating the binding </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae24ef000a161f1a4f7e307a0d9d5edac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BindQueue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>routing_key</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds a queue to an exchange Connects an exchange to a queue on the broker </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the name of the queue to bind </td></tr>
    <tr><td class="paramname">exchange_name</td><td>the name of the exchange to bind </td></tr>
    <tr><td class="paramname">routing_key</td><td>only messages sent to the exchange with this routing key will be delivered to the queue. Defaults to "" which means all messages will be delivered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cd925b2cdbea1dc62610a3a481692be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::BindQueue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>routing_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds a queue to an exchange Connects an exchange to a queue on the broker </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the name of the queue to bind </td></tr>
    <tr><td class="paramname">exchange_name</td><td>the name of the exchange to bind </td></tr>
    <tr><td class="paramname">routing_key</td><td>only messages sent to the exchange with this routing key will be delivered to the queue. Defaults to "" which means all messages will be delivered </td></tr>
    <tr><td class="paramname">arguments</td><td>A table of additional arguments used when binding the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40a9cd7087913e23e91f305a4a601ec3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ptr_t AmqpClient::Channel::Create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em> = <code>&quot;127.0.0.1&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em> = <code>5672</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>username</em> = <code>&quot;guest&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>password</em> = <code>&quot;guest&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vhost</em> = <code>&quot;/&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_max</em> = <code>131072</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new channel object Creates a new connection to an AMQP broker using the supplied parameters and opens a single channel for use </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The hostname or IP address of the AMQP broker </td></tr>
    <tr><td class="paramname">port</td><td>The port to connect to the AMQP broker on </td></tr>
    <tr><td class="paramname">username</td><td>The username used to authenticate with the AMQP broker </td></tr>
    <tr><td class="paramname">password</td><td>The password corresponding to the username used to authenticate with the AMQP broker </td></tr>
    <tr><td class="paramname">vhost</td><td>The virtual host on the AMQP we should connect to </td></tr>
    <tr><td class="paramname">channel_max</td><td>Request that the server limit the number of channels for this connection to the specified parameter, a value of zero will use the broker-supplied value </td></tr>
    <tr><td class="paramname">frame_max</td><td>Request that the server limit the maximum size of any frame to this value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> object pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ac34d478301d58af94af18d2859e5d156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Channel::ptr_t AmqpClient::Channel::CreateFromUri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_max</em> = <code>131072</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> object from an AMQP URI</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>[in] a URI of the form: amqp://[username:password@]{HOSTNAME}[:PORT][/VHOST] </td></tr>
    <tr><td class="paramname">frame_max</td><td>[in] requests that the broker limit the maximum size of any frame to this value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a0506a8d47f576c8f4c62de6fb93468f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ptr_t AmqpClient::Channel::CreateSecure </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_to_ca_cert</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em> = <code>&quot;127.0.0.1&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_to_client_key</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_to_client_cert</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em> = <code>5671</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>username</em> = <code>&quot;guest&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>password</em> = <code>&quot;guest&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vhost</em> = <code>&quot;/&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_max</em> = <code>131072</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify_hostname</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new channel object Creates a new connection to an AMQP broker using the supplied parameters and opens a single channel for use </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_to_ca_cert</td><td>Path to ca certificate file </td></tr>
    <tr><td class="paramname">host</td><td>The hostname or IP address of the AMQP broker </td></tr>
    <tr><td class="paramname">path_to_client_key</td><td>Path to client key file </td></tr>
    <tr><td class="paramname">path_to_client_cert</td><td>Path to client certificate file </td></tr>
    <tr><td class="paramname">port</td><td>The port to connect to the AMQP broker on </td></tr>
    <tr><td class="paramname">username</td><td>The username used to authenticate with the AMQP broker </td></tr>
    <tr><td class="paramname">password</td><td>The password corresponding to the username used to authenticate with the AMQP broker </td></tr>
    <tr><td class="paramname">vhost</td><td>The virtual host on the AMQP we should connect to </td></tr>
    <tr><td class="paramname">channel_max</td><td>Request that the server limit the number of channels for this connection to the specified parameter, a value of zero will use the broker-supplied value </td></tr>
    <tr><td class="paramname">frame_max</td><td>Request that the server limit the maximum size of any frame to this value </td></tr>
    <tr><td class="paramname">verify_host</td><td>Verify the hostname against the certificate when opening the SSL connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> object pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a0be1630633019b433df2bde099ed010d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Channel::ptr_t AmqpClient::Channel::CreateSecureFromUri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_to_ca_cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_to_client_key</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_to_client_cert</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify_hostname</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_max</em> = <code>131072</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> object from an AMQP URI, secured with SSL. If URI should start with amqps://</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>[in] a URI of the form: amqp[s]://[username:password@]{HOSTNAME}[:PORT][/VHOST] </td></tr>
    <tr><td class="paramname">path_to_ca_cert</td><td>Path to ca certificate file </td></tr>
    <tr><td class="paramname">host</td><td>The hostname or IP address of the AMQP broker </td></tr>
    <tr><td class="paramname">path_to_client_key</td><td>Path to client key file </td></tr>
    <tr><td class="paramname">path_to_client_cert</td><td>Path to client certificate file </td></tr>
    <tr><td class="paramname">verify_hostname</td><td>Verify the hostname against the certificate when opening the SSL connection. </td></tr>
    <tr><td class="paramname">frame_max</td><td>[in] requests that the broker limit the maximum size of any frame to this value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classAmqpClient_1_1Channel.html">Channel</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="ab1b44093f03f2ff80a899c24bfa6f3cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::DeclareExchange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_type</em> = <code>Channel::EXCHANGE_TYPE_DIRECT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>durable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_delete</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declares an exchange Creates an exchange on the AMQP broker if it does not already exist </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exchange_name</td><td>the name of the exchange </td></tr>
    <tr><td class="paramname">exchange_type</td><td>the type of exchange to be declared. Defaults to direct other types that could be used: fanout and topic </td></tr>
    <tr><td class="paramname">passive</td><td>Indicates how the broker should react if the exchange does not exist. If passive is true and the exhange does not exist the broker will respond with an error and not create the exchange, exchange is created otherwise. Defaults to false (exchange is created if it does not already exist) </td></tr>
    <tr><td class="paramname">durable</td><td>Indicates whether the exchange is durable - e.g., will it survive a broker restart Defaults to false </td></tr>
    <tr><td class="paramname">auto_delete</td><td>Indicates whether the exchange will automatically be removed when no queues are bound to it. Defaults to false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3693e5617321ee6f6a089ae18b52659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::DeclareExchange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>durable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_delete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declares an exchange Creates an exchange on the AMQP broker if it does not already exist </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exchange_name</td><td>the name of the exchange </td></tr>
    <tr><td class="paramname">exchange_type</td><td>the type of exchange to be declared. Defaults to direct other types that could be used: fanout and topic </td></tr>
    <tr><td class="paramname">passive</td><td>Indicates how the broker should react if the exchange does not exist. If passive is true and the exchange does not exist the broker will respond with an error and not create the exchange, exchange is created otherwise. </td></tr>
    <tr><td class="paramname">durable</td><td>Indicates whether the exchange is durable - e.g., will it survive a broker restart </td></tr>
    <tr><td class="paramname">auto_delete</td><td>Indicates whether the exchange will automatically be removed when no queues are bound to it. </td></tr>
    <tr><td class="paramname">arguments</td><td>A table of additional arguments used when creating the exchange </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12550aaf41bf053be2821556e24fff32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AmqpClient::Channel::DeclareQueue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>durable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_delete</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declares a queue Creates a queue on the AMQP broker if it does not already exist </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the desired name of the queue. If this is a zero-length string the broker will generate a queue name and it will be returned as a result from this method </td></tr>
    <tr><td class="paramname">passive</td><td>Indicated how the broker should react if the queue does not exist. If passive is true and the queue does not exist the borker will respond with an error and not create the queue, the queue is created otherwise. Defaults to false (queue is created if it does not already exist) </td></tr>
    <tr><td class="paramname">durable</td><td>Indicates whether the exchange is durable - e.g., will it survive a broker restart Defaults to false </td></tr>
    <tr><td class="paramname">exclusive</td><td>Indicates that only client can use the queue. Defaults to true. An exclusive queue is deleted when the connection is closed </td></tr>
    <tr><td class="paramname">auto_delete</td><td>the queue will be deleted after at least one exchange has been bound to it, then has been unbound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the queue created on the broker. Used mostly when the broker is asked to create a unique queue by not providing a queue name </dd></dl>

</div>
</div>
<a class="anchor" id="a1c10125d0594225045f1b2b9c77d34f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AmqpClient::Channel::DeclareQueue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>durable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_delete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declares a queue Creates a queue on the AMQP broker if it does not already exist </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the desired name of the queue. If this is a zero-length string the broker will generate a queue name and it will be returned as a result from this method </td></tr>
    <tr><td class="paramname">passive</td><td>Indicated how the broker should react if the queue does not exist. If passive is true and the queue does not exist the borker will respond with an error and not create the queue, the queue is created otherwise. Defaults to false (queue is created if it does not already exist) </td></tr>
    <tr><td class="paramname">durable</td><td>Indicates whether the exchange is durable - e.g., will it survive a broker restart Defaults to false </td></tr>
    <tr><td class="paramname">exclusive</td><td>Indicates that only client can use the queue. Defaults to true. An exclusive queue is deleted when the connection is closed </td></tr>
    <tr><td class="paramname">auto_delete</td><td>the queue will be deleted after at least one exchange has been bound to it, then has been unbound </td></tr>
    <tr><td class="paramname">arguments</td><td>A table of additional arguments used when declaring a queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the queue created on the broker. Used mostly when the broker is asked to create a unique queue by not providing a queue name </dd></dl>

</div>
</div>
<a class="anchor" id="a9f1a6cf9bde40ba9fc9d00c38e4b0af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AmqpClient::Channel::DeclareQueueWithCounts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::uint32_t &amp;&#160;</td>
          <td class="paramname"><em>message_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::uint32_t &amp;&#160;</td>
          <td class="paramname"><em>consumer_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>durable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_delete</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declares a queue and returns current message- and consumer counts Creates a queue on the AMQP broker if it does not already exist </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the desired name of the queue. If this is a zero-length string the broker will generate a queue name and it will be returned as a result from this method </td></tr>
    <tr><td class="paramname">message_count</td><td>Reference to an unsigned int which will receive the current number of messages in the declared queue, if any. </td></tr>
    <tr><td class="paramname">consumer_count</td><td>Reference to an unsigned int which will receive the current number of consumers of the declared queue, if any. </td></tr>
    <tr><td class="paramname">passive</td><td>Indicated how the broker should react if the queue does not exist. If passive is true and the queue does not exist the broker will respond with an error and not create the queue, the queue is created otherwise. Defaults to false (queue is created if it does not already exist) </td></tr>
    <tr><td class="paramname">durable</td><td>Indicates whether the exchange is durable - e.g., will it survive a broker restart Defaults to false </td></tr>
    <tr><td class="paramname">exclusive</td><td>Indicates that only client can use the queue. Defaults to true. An exclusive queue is deleted when the connection is closed </td></tr>
    <tr><td class="paramname">auto_delete</td><td>the queue will be deleted after at least one exchange has been bound to it, then has been unbound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the queue created on the broker. Used mostly when the broker is asked to create a unique queue by not providing a queue name </dd></dl>

</div>
</div>
<a class="anchor" id="a24acc5f08b99944a8277e5643c38d7c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AmqpClient::Channel::DeclareQueueWithCounts </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::uint32_t &amp;&#160;</td>
          <td class="paramname"><em>message_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::uint32_t &amp;&#160;</td>
          <td class="paramname"><em>consumer_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>durable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_delete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declares a queue and returns current message- and consumer counts Creates a queue on the AMQP broker if it does not already exist </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the desired name of the queue. If this is a zero-length string the broker will generate a queue name and it will be returned as a result from this method </td></tr>
    <tr><td class="paramname">message_count</td><td>Reference to an unsigned int which will receive the current number of messages in the declared queue, if any. </td></tr>
    <tr><td class="paramname">consumer_count</td><td>Reference to an unsigned int which will receive the current number of consumers of the declared queue, if any. </td></tr>
    <tr><td class="paramname">passive</td><td>Indicated how the broker should react if the queue does not exist. If passive is true and the queue does not exist the broker will respond with an error and not create the queue, the queue is created otherwise. Defaults to false (queue is created if it does not already exist) </td></tr>
    <tr><td class="paramname">durable</td><td>Indicates whether the exchange is durable - e.g., will it survive a broker restart Defaults to false </td></tr>
    <tr><td class="paramname">exclusive</td><td>Indicates that only client can use the queue. Defaults to true. An exclusive queue is deleted when the connection is closed </td></tr>
    <tr><td class="paramname">auto_delete</td><td>the queue will be deleted after at least one exchange has been bound to it, then has been unbound </td></tr>
    <tr><td class="paramname">arguments</td><td>A table of additional arguments used when declaring a queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the queue created on the broker. Used mostly when the broker is asked to create a unique queue by not providing a queue name </dd></dl>

</div>
</div>
<a class="anchor" id="afac2b0a1fcdbe691bb1b72c460dafb0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::DeleteExchange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>if_unused</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes an exachange on the AMQP broker </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exchange_name</td><td>the name of the exchange to be deleteed </td></tr>
    <tr><td class="paramname">if_unused</td><td>if true only delete the exchange if it has no queues bound to it, throws AmqpResponseServerExeception otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7393af62804d1b9eb03626465ac44696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::DeleteQueue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>if_unused</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>if_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a queue Removes a queue from the broker. There is no indication of whether the queue was actually deleted on the broker. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the name of the queue to remove </td></tr>
    <tr><td class="paramname">if_unused</td><td>only deletes the queue if the queue doesn't have any active consumers. Defaults to false </td></tr>
    <tr><td class="paramname">if_empty</td><td>only deletes the queue if the queue is empty. Defaults to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68f782380ea9a2424a6328017182b7d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::PurgeQueue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purges a queue Removes all the messages in a queue on the broker </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the name of the queue to empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb27cca5c1f9a8a674497a6af8c08765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::UnbindExchange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>routing_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbind an existing exchange-exchange binding </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classAmqpClient_1_1Channel.html#ae614e4e067b9e834b0367aec25b6fb44">BindExchange</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>the name of the exchange to route messages to </td></tr>
    <tr><td class="paramname">source</td><td>the name of the exchange to route messages from </td></tr>
    <tr><td class="paramname">routing_key</td><td>the routing key to use when binding </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa8ad496467f5823097e8293f397ad68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::UnbindExchange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>routing_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbind an existing exchange-exchange binding </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classAmqpClient_1_1Channel.html#ae614e4e067b9e834b0367aec25b6fb44">BindExchange</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>the name of the exchange to route messages to </td></tr>
    <tr><td class="paramname">source</td><td>the name of the exchange to route messages from </td></tr>
    <tr><td class="paramname">routing_key</td><td>the routing key to use when binding </td></tr>
    <tr><td class="paramname">arguments</td><td>A table of additional arguments when unbinding the exchange </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadec3cab20eab13ca2b9d326da88e2f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::UnbindQueue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>routing_key</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbinds a queue from an exchange Disconnects an exchange from a queue </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the name of the queue to unbind </td></tr>
    <tr><td class="paramname">exchange_name</td><td>the name of the exchange to unbind </td></tr>
    <tr><td class="paramname">routing_key</td><td>this must match the routing_key used when creating the binding </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classAmqpClient_1_1Channel.html#ae24ef000a161f1a4f7e307a0d9d5edac">BindQueue</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae71573f5c8b13c83891c8e591e340782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmqpClient::Channel::UnbindQueue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exchange_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>routing_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Table &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbinds a queue from an exchange Disconnects an exchange from a queue </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_name</td><td>the name of the queue to unbind </td></tr>
    <tr><td class="paramname">exchange_name</td><td>the name of the exchange to unbind </td></tr>
    <tr><td class="paramname">routing_key</td><td>this must match the routing_key used when creating the binding </td></tr>
    <tr><td class="paramname">arguments</td><td>A table of additional arguments used when unbinding a queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classAmqpClient_1_1Channel.html#ae24ef000a161f1a4f7e307a0d9d5edac">BindQueue</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Channel_8h_source.html">Channel.h</a></li>
<li>Channel.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
